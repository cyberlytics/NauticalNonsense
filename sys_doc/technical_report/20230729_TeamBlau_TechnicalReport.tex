\documentclass[a4paper, 10pt, conference]{IEEEtran}

\IEEEoverridecommandlockouts

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[colorlinks=true,linkcolor=black,anchorcolor=black,citecolor=black,filecolor=black,menucolor=black,runcolor=black,urlcolor=black]{hyperref}
\usepackage{graphicx}
\usepackage[ngerman]{babel}
\usepackage[style=ieee]{biblatex}
\usepackage[nolist]{acronym}


\addbibresource{references.bib}

\graphicspath{ {./images/} }

  \begin{acronym}
    \acro{uuid}[UUID]{Universally Unique Identifier}
  \end{acronym}

\begin{document}

\makeatletter
\newcommand{\linebreakand}{%
\end{@IEEEauthorhalign}
\hfill\mbox{}\par
\mbox{}\hfill\begin{@IEEEauthorhalign}
}
\makeatother

\title{\LARGE \bf
Nautical Nonsense: Because Sometimes You Just Need to Sink Something
}

\author{

\IEEEauthorblockN{Jakob Götz} 
\IEEEauthorblockA{\textit{j.goetz2@oth-aw.de}}\and
\IEEEauthorblockN{Uwe Kölbel} 
\IEEEauthorblockA{\textit{u.koelbel@oth-aw.de}}\and
\IEEEauthorblockN{Maximilian Schlosser} \IEEEauthorblockA{\textit{m.schlosser@oth-aw.de}}\and
\IEEEauthorblockN{Oliver Schmidts} \IEEEauthorblockA{\textit{o.schmidts@oth-aw.de}}\linebreakand
\IEEEauthorblockN{Jan Schuster} 
\IEEEauthorblockA{\textit{j.schuster@oth-aw.de}}\and
\IEEEauthorblockN{Philipp Seufert} 
\IEEEauthorblockA{\textit{p.seufert@oth-aw.de}}\and
\IEEEauthorblockN{Fabian Wagner} 
\IEEEauthorblockA{\textit{f.wagner@oth-aw.de}}
}

\maketitle
\thispagestyle{empty}
\pagestyle{empty}

\begin{abstract}
Dieser Technical Report beschreibt die Architektur von dem Cloud Native Browser-Game \textit{Nautical Nonsense}. Insbesondere gibt der Report Information über die Planung, Implementierung und welche Werkzeuge für die Umsetzung benötigt wurden.
\end{abstract}


\section{Einleitung}
Schiffeversenken ist seit je her ein beliebtes Spiel. Hauptsächlich wird dieses Spiel jedoch als Brettspiel in Präsenz gespielt. Als 2019 die Corona-Pandemie startete, mussten zwangsweise die Kontakte reduziert werden. Dies ruf eine massive Veränderung in der Lebensweise der Menschen hervor. Besonders im Bereich der Unterhaltung entwickelten sich in kurzer Zeit viele Lösungen, um Aktivitäten, welche zuvor in Präsenz waren, in den Online-Raum zu migrieren. Inspiriert von dieser Entwicklung entstand die Idee, ein Cloud-Nativ Schiffeversenken zu erstellen.\\
In den weiteren Abschnitten dieses Dokuments wird auf die technischen Details des Vorhabens eingegangen. Abschnitt II enthält dabei die Vorgehensweise, welche sicherstellt, dass die Projektziele erreicht werden. Es folgt Abschnitt III, welches einen Überblick über die einzelnen Bausteine gibt und Abschnitt IV, worin die Entwicklungswerkzeuge erläutert werden. Abschließend wird in Abschnitt V auf das Fazit und den Ausblick eingegangen.


\section{Vorgehensweise}\label{sec:vorgehensweise}
\textit{Nautical Nonsense} wurde als Cloud-Nativ Browser-Game Anwendung konzipiert, weshalb sich bei der Vorgehensweise einige Punkte ergaben, welche die grundlegende Struktur des Projektes und die Umsetzung beeinflussten..\\

\textbf{Container} Das Frontend und das Backend ist jeweils in einen extra Container. Bei der Datenbank wurde sich gegen einen separaten Container entschieden, da die verwendete Datenbank bereits eine Option zur Skalierung bereitstellt und eine Ausfallsicherheit garantiert. \\

\textbf{keine Persistenz im Backend} Die Lösungsstrategie im Backend war es eine Kommunikation zu ermöglichen ohne größere Datenmengen darin zu speichern. Da \textit{Nautical Nonsense} als Cloud-Native Anwendung konzipiert wurde, durfte die Persitenz der Daten nicht im Backend gehalten werden. Dies wurde gelöst, indem die Verarbeitung der Daten im Backend erfolgt, jedoch direkt im Anschluss eine Speicherung in der Datenbank vorgenommen wird. \\

\textbf{Kodierung des Spielzustandes} 
Der Spielzustand soll als eine Liste von Zahlen kodiert werden. Dies ermöglicht eine einfache Speicherung und Übertragung des Spielfeldes. 
Zusätzlich werden die Schiffe der Spieler als Liste von Listen bereitgestellt, welche jeweils die Koordinaten des jeweiligen Schiffes enthalten. Ist ein Schiff an einer Stelle getroffen, wird auf diese 100 aufaddiert. \\

\begin{table}[h!]
    \begin{center}
        \caption{Kodierung des Spielfeldes}
        \label{tab:gamefield}
        \begin{tabular}{|c|c|}
            \textbf{Zustand} & \textbf{Beschreibung}\\
            \hline
            \texttt{0}	& Wasser\\
            \texttt{1}	& Wasser getroffen\\
            \texttt{2}	& Schiff\\
            \texttt{3}	& Schiff getroffen\\
            \texttt{4}	& Schiff versenkt\\
        \end{tabular}
    \end{center}
\end{table}

\textbf{Synchronisation im Frontend}
Wenn zwei menschliche Spieler gegeneinander spielen, ist es wichtig, den aktuellen Spielstand zwischen beiden Spielern synchron zu halten. Sobald ein Spieler eine Aktion ausführt und diese an das Backend sendet, muss dieses den zweiten Spieler über die Änderung informieren. Deshalb wird für die Kommunikation im Spiel zwischen Front- und Backend eine Websocket-Verbindung genutzt.

\textbf{Herausforderungen in der Datenbank} 
ein Text welcher die Vorgehensweise, Herausforderungen und Lösungswege beschreibt\\
\textbf{Provisionierung der Infrastruktur} 
Um die Anwendung Cloud-Nativ zu gestalten, wurde auf die Verwendung eines Kubernetes-Clusters zurückgegriffen, welcher auf der Cloud-Plattform \textit{Amazon Web Services} als Managed Service bereitgestellt wird. Die Infrastruktur wurde dabei mit \textit{Terraform} als Code definiert. Dies ermöglicht eine einfache und schnelle Bereitstellung und bei hoher Auslastung die Möglichkeit der Skalierung.\\

\section{Bausteinsicht}\label{sec:bausteinsicht}



\subsection{Datenbank}\label{subsec:datenbank}
Zur dauerhaften Speicherung aller Daten, die während des Spiels anfallen, wird die NoSQL-Datenbank \textit{MongoDB} \cite{mongodb} verwendet. Um den Implementierungsaufwand zu reduzieren, wird dabei auf das Cloudangebot \textit{MongoDB Atlas} \cite{mongodb-atlas} zurückgegriffen. In der Datenbank werden JSON-artige Dokumente in einzelnen Collections abgelegt, die für je eine bestimmte Funktion zuständig sind. Tabelle \ref{tab:collections} zeigt eine Übersicht über die vorhandenen Collections.

\begin{table}[h!]
    \begin{center}
        \caption{Collections}
        \label{tab:collections}
        \begin{tabular}{|l|l|}
            \textbf{collection} & \textbf{Beschreibung}\\
            \hline
            \texttt{games}				& Aktuelle Spielzustände\\
            \texttt{leaderboard}					& Bestenliste\\
            \texttt{stats}	& Spielstatistiken\\
        \end{tabular}
    \end{center}
\end{table}

In \texttt{games} werden die aktuellen Spielstände jedes Spiels gespeichert. Hierzu gehören neben einer eindeutigen Game-ID Informationen zu den Spielern, deren momentane Spielfelder sowie getroffene und versenkte Schiffe.

Ist ein Spiel zu Ende, wird der Gewinner zusammen mit seiner benötigten Zuganzahl in \texttt{leaderboard} gespeichert. Außerdem werden Daten zu Kapitulation und Gegner (Mensch oder Computer) ergänzt, sodass im Frontend zwei getrennte Bestenlisten angezeigt werden können.

Die Spielstatistiken werden ebenso nach jedem beendeten Spiel aktualisiert. Ein Dokument in \texttt{stats} enthält dabei Daten zu bereits abgeschlossenen Spielen, wie Spielanzahl und durchschnittliche Schusszahl - getrennt nach Mensch- und Computergegner. Zusätzlich werden häufige Schiffs- und Schusspositionen sowie die Abschussquote der einzelnen Schiffstypen protokolliert.

\subsection{Backend}\label{subsec:backend}
Das Backend ist mit Python und dem Framework FastAPI \cite{fastapi} umgesetzt. Das Frontend kommuniziert mit dem Backend über zwei Schnittstellen. Zum einen über die RESTful-API, zum anderen über eine Websocket-Verbindung. Die RESTful-API übernimmt alle Anfragen des Frontends, welche nicht die Kommunikation zwischen zwei Spieler betrifft. Somit dient die RESTful-API hauptsächlich als Knotenpunkt zur Datenbank. Die Websocket-Schnittstelle dient zur Kommunikation zwischen zwei Frontends. Die Kommunikationsdaten der Websocket-Verbindung werden im Backend aufbereitet, validiert und in der Datenbank gespeichert. Darauf folgt eine sofortige Antwort an beide Frontends, um diese über den neuen Spielschritt zu informieren.

Folgende HTTP-Endpunkte in Tabelle \ref{tab:api}, stellt die API im Backend für das Frontend zur Verfügung:

\begin{table}[h!]
    \begin{center}
        \caption{RESTful-API}
        \label{tab:api}
        \begin{tabular}{|l|l|}
            \textbf{Endpunkt} & \textbf{Beschreibung}\\
            \hline
            \texttt{GET \, /}				& Startseite\\
            \texttt{POST /play}					& Starten eines neuen Spiels\\
            \texttt{WEBSOCKET /ws/}\detokenize{{client_id}}	& Kommunikation der Spieler\\
            \texttt{GET /leaderboard}	& Daten für das Leaderboard\\
	    \texttt{GET /stats}	& Daten für Spielstatistiken\\
        \end{tabular}
    \end{center}
\end{table}


Die \texttt{/}-Route gibt eine \ac{uuid} als String zurück, welche das Frontend nutzen kann, um den Spieler gegenüber des Backends bei nachfolgenden Anfragen eindeutig zu bestimmen. Ein Spiel wird mit der \texttt{/play}-Route gestartet. Diese Route nimmt ein JSON-Objekt entgegen, in welchen spezifiziert wird, welchen Spielmodus der Spieler spielen möchte. Als Rückgabe bekommt das jeweilige Frontend eine Ready-Flag und die \ac{uuid} der beiden Kontrahenten. Nachdem ein Spiel bereit ist, wird die Websocket-Verbindung über die \texttt{/ws/}-Route aufgebaut. Über diese Route läuft die komplette Kommunikation bis zum Spielende.

\begin{figure}[thp]
    \centering
    \includegraphics[width=\linewidth]{websocket_comm}
    \caption{Websocket Kommunikation}
    \label{fig:websocket_comm}
\end{figure}

In Grafik \ref{fig:websocket_comm} wird die Kommunikation zwischen zwei Spielern und dem Backend während des Spielverlaufs ersichtlich. Im ersten Schritt wird bei erfolgreichen Verbindungsaufbau der beiden Spieler ein \texttt{ready}-Flag vom Backend gesendet. Daraufhin können die Clients ihre Schiffe platzieren und die Position dem Backend übermitteln. Erst wenn beide Spieler ihre Schiffe platziert haben, wird das \texttt{ship\_placement\_ready}-Flag vom Backend auf True gesetzt und der Spielablauf beginnt. Hier übermitteln die Spieler jeweils eine Reihe an Parametern, damit das Backend den Spielfluss steuern kann. Das Spiel endet, wenn ein Spieler alle Schiffe des gegenüber versenkt hat. Darauf folgt, dass der Rückgabewert für lose gesetzt wird. Es folgt lediglich vom Backend die Spielstatistik über das gespielte Spiel. Danach wird die Websocket-Verbindung von den Spielern aufgelöst.

\subsection{Frontend}\label{subsec:frontend}

Zu Beginn des Spieles befindet sich der Spieler auf der Startseite, die es ihm ermöglicht, einen Spielernamen und die Art des Spiels auszuwählen. Zusätzlich kann der Nutzer auf die Optionen-Seite wechseln. Diese dient als "Hub" für weitere Szenen. Über die Optionen sind das Leaderboard, die Statistiken, die Spielanleitung und die Credits zu erreichen. 

%TODO Leaderboard, Statistics, Spieleanleitung

Sind alle nötigen Eingaben getroffen kann mit der Partie begonnen werden.

Die nächste Szene erlaubt es dem Spieler, die Schiffe auf dem Spielfeld zu platzieren. Dazu kann er jedes Schiff einzeln durch anklicken oder alle auf einmal über den Random-Button platzieren. Die einzelnen Fahrzeuge können nach dem Anwählen durch einen Klick rotiert und verschoben werden. Der Reset-Knopf setzt die Schiffe an ihre ursprüngliche Position zurück. Sind alle Schiffe platziert, können die Positionen mit Confirm bestätigt werden.

In der eigentlichen Spielszene wird das Spielfeld mit den zuvor platzierten Schiffen und eine Wahlmöglichkeit zum Platzieren von Schüssen auf die gegnerische Flotte angezeigt. Die beiden Spieler sind dabei abwechselnd am Zug. Die Treffer und Fehlschüsse werden entsprechend auf dem eigenen Spielfeld und dem Feld des Gegners angezeigt. Über den Capitulate-Button kann die Partie durch Aufgabe beendet werden. 

Ist ein Spieldurchlauf beendet, entweder durch Kapitulation eines Spielers oder durch Versenken aller Schiffe eines Teilnehmers, wird in eine entsprechende Gewinner- oder Verlierer Szene gewechselt.

%TODO Endszene



\subsubsection{Kommunikation mit Backend}\label{subsec:comwithbackend}

Beim Aufrufen der Webseite sendet der Client einen HTTP-GET-Request an die Startseite und erhält ein JSON-Objekt mit der Client-ID. Diese ID wird der globalen Variable \textit{sharedData.clientID} zugewiesen.

Die Websocket-Verbindungs-URL wird durch das Hinzufügen der Client-ID zu \textit{sharedData.websocket\_url} erstellt.

Wenn der Client in der Start-Szene \glqq Spiel gegen Random\grqq{} auswählt, erfolgt ein HTTP-POST-Request an die \texttt{/play}-Route mit Informationen wie der Client-ID, dem ausgewählten Modus und dem Spielernamen. Die empfangene Game-ID wird in \textit{sharedData.game\_id} gespeichert.

Die Websocket-Verbindung wird erst nach erfolgreicher Ausführung dieses Befehls initialisiert, bevor zur Szene \glqq Waiting1\grqq{} gewechselt wird. Dieser Websocket existiert ebenfalls als globale Variable namens \textit{sharedData.socket}.

In allen Szenen ist die Methode \textit{onmessage} implementiert, die es ermöglicht, über Websockets eingehende Nachrichten vom Backend zu empfangen. Diese Methode ist Bestandteil des JavaScript-Objekts \textit{WebSocket}.

Wenn sich ein zweiter Client auf der Webseite verbindet und die Option \glqq Spiele gegen Random\grqq{} auswählt, sendet das Backend über die Websocket-Verbindung ein \glqq ready\grqq{}-Flag an beide Clients. In Folge dessen wird die Variable \textit{sharedData.ready} auf den Wert \glqq true\grqq{} gesetzt und es erfolgt ein nahtloser Wechsel zur Szene \glqq Shipplacement\grqq{}.

In dieser Szene wird die Platzierung der Schiffe (Positionen) und die Game-ID an das Backend über die Websocket-Verbindung übermittelt. Für das Senden wird zuerst überprüft, ob die Websocket-Verbindung steht und anschließend die Methode \textit{JSON.stringify} verwendet, um ein JSON-Objekt in einen JSON-String zu konvertieren. Dieser wird anschließend mittels \textit{sharedData.socket.send(JSON-String)} an das Backend gesendet.

 Die grundlegende Vorgehensweise beim Empfangen und Senden von Nachrichten via Websockets ändert sich in den restlichen Szenen nicht. Es wurde lediglich die Verarbeitung der Daten auf den jeweiligen Use-Case angepasst. In Abbildung \ref{fig:websocket_comm} ist ein Schaubild der Websocket-Kommunikation ersichtlich.





\subsection{Infrastruktur}\label{subsec:infrastruktur}

Für die Bereitstellung der Anwendung in der Cloud wird ein Kubernetes-Cluster \cite{k8s} verwendet. 
Um eine nachvollziehbare und deklarative Konfiguration zu gewährleisten, wurde Terraform \cite{terraform} als Infrastructure-as-Code-Tool verwendet. 
Alle Bestandteile des Setups können somit über eine CI/CD-Pipeline, welche per Weboberfläche in Gitlab ausgelöst wird, direkt deployt werden.
Als Cloud-Anbieter wurde Amazon Web Services (AWS) \cite{aws} gewählt. Die einzelnen Komponenten werden im Folgenden näher erläutert und sind in Abbildung \ref{fig:infra} dargestellt.
Der erste Schritt beinhaltet die Erstellung einer Virtual Private Cloud (VPC) mit privaten und öffentlichen Subnetzen in verschiedenen Availability Zones (AZs).
Anschließend werden die privaten Subnetze für die Provisionierung des Kubernetes-Clusters verwendet, während in eines der öffentlichen Subnetze ein NAT-Gateway für den Internetzugriff der Pods erstellt wird.
Zusätzlich werden die benötigten IAM-Rollen und Policies für den Zugriff auf die AWS-Ressourcen erstellt.
Zuletzt erfolgt die Erstellung eines AWS Load Balancer Controllers als Ingress Controller für den Zugriff auf die Anwendung von außen.
Nach dem Aufsetzen der Infrastruktur wird über die CI/CD-Pipeline ein Test-Deployment durchgeführt, um die Erreichbarkeit des Clusters zu überprüfen und den erfolgreichen Ablauf aller Operationen zu gewährleisten.
Des Weiteren wird das Kubernetes Dashboard installiert, um die einzelnen Komponenten des Clusters zu überwachen.
Ebenfalls ist es möglich, über eine zweite Pipeline ein manuelles Deployment der Anwendung durchzuführen.
Hierfür werden Docker-Container verwendet, die erstellt werden, wenn ein Tag auf dem default-Branch erstellt wird.

\begin{figure}[thp]
    \centering
    \includegraphics[width=\linewidth]{k8s}
    \caption{Überblick Kubernetes-Cluster}
    \label{fig:infra}
\end{figure}

\section{Entwicklungswerkzeuge}\label{sec:entwicklungswerkzeuge}



\subsection{Backend}\label{subsec:backend-dev-tools}
Das Backend wird hauptsächlich mit FastAPI implementiert, einem Framework, das auf Starlette \cite{starlette} und Pydantic \cite{pydantic} aufbaut. Starlette stellt Funktionen wie WebSockets zur Verfügung, während Pydantic die Validierung von Datenmodellen ermöglicht, die von FastAPI verwendet werden. Dank Starlette kann auch das Test-Framework Pytest \cite{pytest} direkt für Unit-Tests eingesetzt werden. Der Asynchronous Server Gateway Interface (ASGI) Server Uvicorn \cite{uvicorn} wird für die Bereitstellung genutzt. Für den Zugriff auf die Mongo-Datenbank wird das Framework PyMongo \cite{pymongo} genutzt. 




\subsection{Frontend}\label{subsec:frontend-dev-tools}

Um das Frontend zu realisieren, wird Phaser3 \cite{phaser} verwendet. Dabei handelt es sich um ein Framework zur Realisierung von Browser-Spielen auf Desktop und mobilen Geräten. Phaser bietet dazu mehrere Funktionen vom Erzeugen und Importieren verschiedener Canvas-Elemente und Assets bis hin zu einfacher Physiksimulation und Szenenverwaltung.

Als Entwicklungsumgebung wird der Phaser Editor 2D eingesetzt. Dieser erlaubt das Erzeugen einer Projektgrundstruktur, die im Verlauf der Arbeit immer weiter angepasst und ausgebaut wird.  

Für die Tests im Frontend werden eine Vielzahl an Werkzeugen genutzt. Die Verwaltung dieser erfolgt über npm \cite{npm}. Phaser3 benötigt zur problemfreien Funktion ein Document-Object-Modell (DOM). Das Frontend-Test Framework Cypress \cite{cypress} bietet mit seinem End-to-End Modus ein solches DOM und erlaubt damit das automatisierte testen des Frontends. Um die Testabdeckung zu messen kommt istanbul \cite{istanbul} zum Einsatz.



\section{Fazit und Ausblick}\label{sec:fazit}
In dieser Arbeit wurde eine Anwendung erstellt, welche das Brettspiel Schiffeversenken als Cloud-Nativ Browser-Spiel umsetzt. Der Nutzer kann gegen zufällige Gegner spielen und sich Statistiken über das gespielte Spiel oder vergangene Spiele anzeigen lassen. Umrahmt wird die Anwendung durch 2D-Modelle, Spielmusik und Einstellungsmöglichkeiten über ein Optionsmenü. Hauptaugenmerk dieser Applikation ist die Cloud-Architektur, welche eine Skalierung zulässt und Ausfallsicherheit garantiert. Somit kann auch eine große Anzahl von Spielern gleichzeitig das Browser-Spiel nutzen.\\
Eine Erweiterung dieser Arbeit könnte vor allem im Umfang der Spielarten stattfinden. Die Grundlagen für das Spiel gegen Computergegner als auch Freund sind gelegt. Zusätzlich wäre eine Chat-Option über die bereits bestehende Websocket-Verbindung realisierbar. \\



\printbibliography

\end{document}

